`#!/usr/bin/env node`

const
  fs = require('fs')
  assert = require('assert')
const DEFAULT_PIDFILE = 'naught.pid'

function wait (seconds, cb)
  setTimeout(cb, seconds * 1000)

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      obj[arg.substring(2)] = argv.shift()
    else
      return arg
  null

!function readPid(pidfile, cb)
  fs.readFile pidfile, \utf8, !(err, data) ->
    assert.ifError err
    pid = parseInt(data)
    if isNaN(pid)
      console.error "Invalid pid in pidfile: #{pidfile}"
      process.exit(1)
    cb(pid)

!function printUsage
  console.log "Usage:"
  for name, cmd in cmds
    console.log "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  {spawn} = require('child_process')
  path = require('path')

  fs.stat options.pidfile, !(err, stats) ->
    unless err?code is \ENOENT
      console.error("pidfile #{options.pidfile} already exists.")
      console.error("Stop the old server before starting a new one.")
      return
    child = spawn(process.execPath, [
      path.join(__dirname, "daemon.js"),
      options.'worker-count',
      options.pidfile,
      options.log,
      options.stderr,
      options.stdout,
      script,
    ].concat(argv), {
      env: process.env
      stdio: ['ignore', 'ignore', 'ignore']
      detached: true
      cwd: options.cwd
    })
    child.unref()


!function stopScript (options, pidfile)
  readPid pidfile, !(pid) ->
    try
      process.kill(pid, 'SIGTERM')
    catch e
      if e.code is \ESRCH
        console.error("Warning: no process killed with pid #pid.")
      else
        throw e
    finally
      fs.unlink(pidfile)

!function deploy (options, pidfile)
  readPid pidfile, !(pid) ->
    process.kill(pid, 'SIGUSR1')

!function deployAbort (pidfile)
  readPid pidfile, !(pid) ->
    process.kill(pid, 'SIGUSR2')

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Available options and their defaults:

        --worker-count 1
        --pidfile #DEFAULT_PIDFILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd .
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'pidfile': DEFAULT_PIDFILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
      script = chompArgv(options, argv)
      if script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [pidfile.pid]

        Stops the running server which created the pidfile.
        Uses `#DEFAULT_PIDFILE` by default.

        This sends SIGTERM to the process and waits for timeout, then
        sends SIGKILL if the process has not already exited.

        Available options and their defaults:

            --timeout 5
    """
    fn: (argv) ->
      options =
        timeout: '5'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = parseFloat(options.timeout)
        stopScript(options, pidfile)
        true
      else
        false

  deploy:
    help: """
    naught deploy [options] [pidfile.pid]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command. Naught does this one
        worker at a time, and waits to kill a worker until after the
        replacement is online.
        Uses `#DEFAULT_PIDFILE` by default.

        Available options and their defaults:

            --replace-env true
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = options.timeout is \true
        deploy(options, pidfile)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [pidfile.pid]

        Aborts a hanging deploy. A hanging deploy happens when a new worker
        fails to emit the 'online' message, or when an old worker fails
        to shutdown upon receiving the 'shutdown' message.

        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      deployAbort(pidfile)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.log(cmd.help)
else
  printUsage()
