`#!/usr/bin/env node`

const
  fs = require('fs')
  os = require('os')
  net = require('net')
  assert = require('assert')
  json_socket = require('./json_socket')
const DEFAULT_PIDFILE = 'naught.json'

function wait (seconds, cb)
  setTimeout(cb, seconds * 1000)

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      arg_name = arg.substring(2)
      if arg_name not in obj
        return [new Error('InvalidArgument'), null]
      if argv.length is 0
        return [new Error('MissingArgument'), null]
      obj[arg_name] = argv.shift()
    else
      return [null, arg]
  return [null, null]

!function readPids (pidfile, cb)
  fs.readFile pidfile, \utf8, !(err, data) ->
    if err?code is \ENOENT
      console.error "server not running"
      process.exit(1)
      return
    assert.ifError err
    try
      pids = JSON.parse(data)
    catch
      console.error "Invalid pidfile: #{pidfile}"
      process.exit(1)
    cb(pids)

function getDaemonMessages (socket_path, cbs)
  socket = net.connect socket_path, cbs.ready
  json_socket.listen(socket, cbs.event)
  socket

!function printUsage
  for name, cmd in cmds
    console.error "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  {spawn} = require('child_process')
  path = require('path')

  fs.stat options.pidfile, !(err, stats) ->
    unless err?code is \ENOENT
      console.error("pidfile #{options.pidfile} already exists.")
      console.error("Stop the old server before starting a new one.")
      return
    child = spawn(process.execPath, [
      path.join(__dirname, "daemon.js"),
      options.'worker-count',
      options.pidfile,
      options.log,
      options.stderr,
      options.stdout,
      options.'max-log-size',
      options.tmp,
      script,
    ].concat(argv), {
      env: process.env
      stdio: \inherit
      detached: true
      cwd: options.cwd
    })
    child.unref()


!function stopScript (options, pidfile)
  readPids pidfile, !(pids) ->
    timeout_term = null
    timeout_kill = null
    {timeout} = options
    if timeout?
      timeout_term = wait timeout, !->
        pid = pids.master
        console.error "Timeout. Sending SIGTERM"
        tryProcessKill(pid, 'SIGTERM', pidfile)
        timeout_kill := wait timeout, !->
          console.error "Timeout. Sending SIGKILL"
          tryProcessKill(pid, 'SIGKILL', pidfile)
    socket = getDaemonMessages pids.socket,
      ready: !->
        json_socket.send socket, action: \NaughtShutdown
      event: !(msg) ->
        if msg.event is \Shutdown
          clearTimeout(timeout_term) if timeout_term?
          clearTimeout(timeout_kill) if timeout_kill?
          process.exit(0)
        else
          printDaemonMsg msg

!function printDaemonMsg (msg)
  console.error "event: #{msg.event}, old: #{msg.old_count}, new: #{msg.new_count}, dying: #{msg.dying_count}"

function tryProcessKill (pid, signal, pidfile)
  try
    process.kill(pid, signal)
  catch e
    if e.code is \ESRCH
      console.error("No process killed with pid #pid.")
      console.error("`rm #pidfile` manually after ensuring your server is not already running.")
      process.exit(1)
    else
      throw e
  return true

!function deploy (options, pidfile)
  readPids pidfile, !(pids) ->
    socket = getDaemonMessages pids.socket,
      ready: !->
        process.once \SIGINT, !->
          console.error "aborting deploy"
          json_socket.send socket, action: \NaughtDeployAbort
        json_socket.send socket,
          action: \NaughtDeploy
          environment: if options.'replace-env' then process.env else null
      event: !(msg) ->
        switch msg.event
          case \ErrorDeployInProgress
            console.error "Deploy already in progress. Things you can do:"
            console.error "1. monitor #{pids.log.naught}"
            console.error "2. abort the deploy. see `naught help deploy-abort`"
            process.exit(1)
          case \Ready
            console.error "done"
            process.exit(0)
          default
            printDaemonMsg msg

!function deployAbort (pidfile)
  readPids pidfile, !(pids) ->
    socket = getDaemonMessages pids.socket,
      ready: !->
        json_socket.send socket, action: \NaughtDeployAbort
      event: !(msg) ->
        switch msg.event
          case \ErrorNoDeployInProgress
            console.error "no deploy in progress"
            process.exit(1)
          case \Ready
            console.error "deploy aborted"
            process.exit(0)
          default
            printDaemonMsg msg

!function displayStatus (pidfile)
  readPids pidfile, !(pids) ->
    console.log "#{pids.daemon} #{pids.master} #{pids.script}"

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Each worker's stdout and stderr are redirected to a log files
        specified by the `stdout` and `stderr` parameters. When a log file
        becomes larger than the `max-log-size` parameter, the log file
        is gzipped and renamed using the current date and time, and a new
        log file is opened.

        Available options and their defaults:

        --worker-count 1
        --pidfile #DEFAULT_PIDFILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd #{process.cwd()}
        --tmp #{os.tmpDir()}
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'pidfile': DEFAULT_PIDFILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
        'tmp': os.tmpDir()
      [err, script] = chompArgv(options, argv)
      if not err and script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [pidfile]

        Stops the running server which created the pidfile.
        Uses `#DEFAULT_PIDFILE` by default.

        This sends the 'shutdown' message to all the workers and waits for
        them to exit gracefully.

        If you specify a timeout, naught will wait for the seconds to pass,
        and then send a SIGTERM to kill your server. Naught will then wait
        for timeout again, finally sending a SIGKILL to your server if it
        has not exited on its own.

        Available options and their defaults:

            --timeout none
    """
    fn: (argv) ->
      options =
        timeout: 'none'
      [err, pidfile or DEFAULT_PIDFILE] = chompArgv(options, argv)
      if not err and argv.length is 0
        options.timeout = parseFloat(options.timeout)
        options.timeout = null if isNaN(options.timeout)
        stopScript(options, pidfile)
        true
      else
        false

  status:
    help: """
    naught status [pidfile]

        Displays whether a server is running or not.
        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      displayStatus(pidfile)
      true

  deploy:
    help: """
    naught deploy [options] [pidfile]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command.

        Naught spawns all the new workers and waits for them to all become
        online before killing a single old worker. This guarantees zero
        downtime if any of the new workers fail and provides the ability to
        cleanly abort the deployment if it hangs.

        Uses `#DEFAULT_PIDFILE` by default.

        Available options and their defaults:

            --replace-env true
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
      [err, pidfile or DEFAULT_PIDFILE] = chompArgv(options, argv)
      if not err and argv.length is 0
        options.'replace-env' = options.'replace-env' is \true
        deploy(options, pidfile)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [pidfile]

        Aborts a hanging deploy. A hanging deploy happens when a new worker
        fails to emit the 'online' message, or when an old worker fails
        to shutdown upon receiving the 'shutdown' message.

        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      deployAbort(pidfile)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.error(cmd.help)
else
  printUsage()
