`#!/usr/bin/env node`

const
  fs = require('fs')
  assert = require('assert')
const DEFAULT_PIDFILE = 'naught-pid.json'

function wait (seconds, cb)
  setTimeout(cb, seconds * 1000)

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      obj[arg.substring(2)] = argv.shift()
    else
      return arg
  null

!function readPids (pidfile, cb)
  fs.readFile pidfile, \utf8, !(err, data) ->
    if err?code is \ENOENT
      console.error "server not running"
      process.exit(1)
      return
    assert.ifError err
    try
      pids = JSON.parse(data)
    catch
      console.error "Invalid pidfile: #{pidfile}"
      process.exit(1)
    cb(pids)

!function getDaemonMessages (socket_path, cbs)
  net = require('net')
  socket = net.connect socket_path, cbs.ready
  socket.setEncoding \utf8
  socket.on \data, !(data) ->
    msg = JSON.parse(data)
    cbs.event?(msg)

!function printUsage
  for name, cmd in cmds
    console.error "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  {spawn} = require('child_process')
  path = require('path')

  fs.stat options.pidfile, !(err, stats) ->
    unless err?code is \ENOENT
      console.error("pidfile #{options.pidfile} already exists.")
      console.error("Stop the old server before starting a new one.")
      return
    child = spawn(process.execPath, [
      path.join(__dirname, "daemon.js"),
      options.'worker-count',
      options.pidfile,
      options.log,
      options.stderr,
      options.stdout,
      options.tmp,
      script,
    ].concat(argv), {
      env: process.env
      stdio: \inherit
      detached: true
      cwd: options.cwd
    })
    child.unref()


!function stopScript (options, pidfile)
  readPids pidfile, !(pids) ->
    try
      process.kill(pids.master, 'SIGTERM')
    catch e
      if e.code is \ESRCH
        console.error("No process killed with pid #{pids.master}.")
        console.error("`rm #{pidfile}` manually after ensuring your server is not already running.")
      else
        throw e

!function deploy (options, pidfile)
  readPids pidfile, !(pids) ->
    getDaemonMessages pids.socket,
      ready: !-> process.kill(pids.master, 'SIGUSR1')
      event: !(msg) ->
        switch msg.event
          case \ErrorDeployInProgress
            console.error "There is deploy already in progress. Things you can do:"
            console.error "1. monitor #{pids.log.naught}"
            console.error "2. abort the deploy. see `naught help deploy-abort`"
            process.exit(1)
          default
            console.error "event: #{msg.event}, old: #{msg.old_count}, new: #{msg.new_count}"

!function deployAbort (pidfile)
  readPids pidfile, !(pids) ->
    getDaemonMessages pids.socket,
      ready: !-> process.kill(pids.master, 'SIGUSR2')
      event: !(msg) ->
        switch msg.event
          case \ErrorNoDeployInProgress
            console.error "no deploy in progress"
            process.exit(1)
          default
            console.error "event: #{msg.event}, old: #{msg.old_count}, new: #{msg.new_count}"

!function displayStatus (pidfile)
  readPids pidfile, !(pids) ->
    console.log "#{pids.daemon} #{pids.master} #{pids.script}"

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Available options and their defaults:

        --worker-count 1
        --pidfile #DEFAULT_PIDFILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd .
        --tmp /tmp
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'pidfile': DEFAULT_PIDFILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
        'tmp': '/tmp'
      script = chompArgv(options, argv)
      if script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [pidfile]

        Stops the running server which created the pidfile.
        Uses `#DEFAULT_PIDFILE` by default.

        This sends SIGTERM to the process and waits for timeout, then
        sends SIGKILL if the process has not already exited.

        Available options and their defaults:

            --timeout 5
    """
    fn: (argv) ->
      options =
        timeout: '5'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = parseFloat(options.timeout)
        stopScript(options, pidfile)
        true
      else
        false

  status:
    help: """
    naught status [pidfile]

        Displays whether a server is running or not.
        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      displayStatus(pidfile)
      true

  deploy:
    help: """
    naught deploy [options] [pidfile]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command. Naught does this one
        worker at a time, and waits to kill a worker until after the
        replacement is online.
        Uses `#DEFAULT_PIDFILE` by default.

        Available options and their defaults:

            --replace-env true
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = options.timeout is \true
        deploy(options, pidfile)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [pidfile]

        Aborts a hanging deploy. A hanging deploy happens when a new worker
        fails to emit the 'online' message, or when an old worker fails
        to shutdown upon receiving the 'shutdown' message.

        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      deployAbort(pidfile)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.error(cmd.help)
else
  printUsage()
