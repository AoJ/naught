`#!/usr/bin/env node`

const DEFAULT_PIDFILE = 'naught.pid'

function wait (seconds, cb)
  setTimeout(cb, seconds * 1000)

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      obj[arg.substring(2)] = argv.shift()
    else
      return arg
  null

!function printUsage
  console.log "Usage:"
  for name, cmd in cmds
    console.log "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  {spawn} = require('child_process')
  path = require('path')

  log_naught = fs.createWriteStream options.log,
    flags: 'a'
    encoding: 'utf8'
  log_stderr = fs.createWriteStream options.stderr,
    flags: 'a'
    encoding: 'utf8'
  log_stdout = fs.createWriteStream options.stdout,
    flags: 'a'
    encoding: 'utf8'

  !function log (str)
    log_naught.write str
    process.stdout.write str

  child = spawn(process.execPath, [
    path.join(__dirname, "wrapper.js"),
    options.'worker-count',
    options.cwd,
    script,
  ].concat(argv), {
    env: process.env
    stdio: ['inherit', 'pipe', 'pipe']
    detached: true
    cwd: options.cwd
  })
  child.stdout.pipe(log_stdout)
  child.stderr.pipe(log_stderr)
  fs.writeFile options.pidfile, child.pid.toString(), \utf8, !(err) ->
    if err then log "Error: Unable to write pidfile to #{options.pidfile}.\n#{err.stack}\n"

!function stopScript (options, pidfile)
  fs.readFile pidfile, \utf8, !(err, data) ->
    pid = parseInt(data)
    process.kill(pid, 'SIGTERM')
    wait options.timeout, !->
      process.kill(pid, 'SIGKILL')

!function deploy (options, pidfile)
  fs.readFile pidfile, \utf8, !(err, data) ->
    pid = parseInt(data)
    process.kill(pid, 'SIGUSR1')

!function deployAbort (pidfile)
  fs.readFile pidfile, \utf8, !(err, data) ->
    pid = parseInt(data)
    process.kill(pid, 'SIGUSR2')

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Available options and their defaults:

        --worker-count 1
        --pidfile #DEFAULT_PIDFILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd .
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'pidfile': DEFAULT_PIDFILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
      script = chompArgv(options, argv)
      if script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [pidfile.pid]

        Stops the running server which created the pidfile.
        Uses `#DEFAULT_PIDFILE` by default.

        This sends SIGTERM to the process and waits for timeout, then
        sends SIGKILL if the process has not already exited.

        Available options and their defaults:

            --timeout 5
    """
    fn: (argv) ->
      options =
        timeout: '5'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = parseFloat(options.timeout)
        stopScript(options, pidfile)
        true
      else
        false

  deploy:
    help: """
    naught deploy [options] [pidfile.pid]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command. Naught does this one
        worker at a time, and waits to kill a worker until after the
        replacement is online.
        Uses `#DEFAULT_PIDFILE` by default.

        Available options and their defaults:

            --replace-env true
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
      pidfile = chompArgv(options, argv) or DEFAULT_PIDFILE
      if argv.length is 0
        options.timeout = options.timeout is \true
        deploy(options, pidfile)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [pidfile.pid]

    Aborts a hanging deploy. A hanging deploy happens when a new worker
    fails to emit the 'online' message, or when an old worker fails
    to shutdown upon receiving the 'shutdown' message.

    Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      deployAbort(pidfile)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.log(cmd.help)
else
  printUsage()
