`#!/usr/bin/env node`

const
  fs = require('fs')
  os = require('os')
  net = require('net')
  assert = require('assert')
  json_socket = require('./json_socket')
const DEFAULT_PIDFILE = 'naught.json'

function wait (seconds, cb)
  setTimeout(cb, seconds * 1000)

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      arg_name = arg.substring(2)
      if arg_name not in obj
        return [new Error('InvalidArgument'), null]
      if argv.length is 0
        return [new Error('MissingArgument'), null]
      obj[arg_name] = argv.shift()
    else
      return [null, arg]
  return [null, null]

!function readPids (pidfile, cb)
  fs.readFile pidfile, \utf8, !(err, data) ->
    if err?code is \ENOENT
      console.error "server not running"
      process.exit(1)
      return
    assert.ifError err
    try
      pids = JSON.parse(data)
    catch
      console.error "Invalid pidfile: #pidfile"
      process.exit(1)
    ps = require('./ps')
    ps.isRunning pids.master, !(err, is_running) ->
      assert.ifError err
      if not is_running
        console.error "server not running"
        fs.unlinkSync(pidfile)
        process.exit(1)
        return
      cb(pids)

function getDaemonMessages (socket_path, cbs)
  socket = net.connect socket_path, cbs.ready
  json_socket.listen(socket, cbs.event)
  socket

!function printUsage
  for name, cmd in cmds
    console.error "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  {spawn} = require('child_process')
  path = require('path')

  fs.stat options.pidfile, !(err, stats) ->
    unless err?code is \ENOENT
      console.error("pidfile #{options.pidfile} already exists.")
      console.error("Stop the old server before starting a new one.")
      return
    child = spawn(process.execPath, [
      path.join(__dirname, "daemon.js"),
      options.'worker-count',
      options.pidfile,
      options.log,
      options.stderr,
      options.stdout,
      options.tmp,
      script,
    ].concat(argv), {
      env: process.env
      stdio: \inherit
      detached: true
      cwd: options.cwd
    })
    child.unref()


!function stopScript (options, pidfile)
  readPids pidfile, !(pids) ->
    try
      process.kill(pids.master, 'SIGTERM')
    catch e
      if e.code is \ESRCH
        console.error("No process killed with pid #{pids.master}.")
        console.error("`rm #pidfile` manually after ensuring your server is not already running.")
      else
        throw e

!function printDaemonMsg (msg)
  console.error "event: #{msg.event}, old: #{msg.old_count}, new: #{msg.new_count}, dying: #{msg.dying_count}"

!function deploy (options, pidfile)
  readPids pidfile, !(pids) ->
    socket = getDaemonMessages pids.socket,
      ready: !->
        process.once \SIGINT, !->
          console.error "aborting deploy"
          json_socket.send socket, action: \NaughtDeployAbort
        json_socket.send socket,
          action: \NaughtDeploy
          environment: if options.'replace-env' then process.env else null
      event: !(msg) ->
        switch msg.event
          case \ErrorDeployInProgress
            console.error "Deploy already in progress. Things you can do:"
            console.error "1. monitor #{pids.log.naught}"
            console.error "2. abort the deploy. see `naught help deploy-abort`"
            process.exit(1)
          case \Ready
            console.error "done"
            process.exit(0)
          default
            printDaemonMsg msg

!function deployAbort (pidfile)
  readPids pidfile, !(pids) ->
    socket = getDaemonMessages pids.socket,
      ready: !->
        json_socket.send socket, action: \NaughtDeployAbort
      event: !(msg) ->
        switch msg.event
          case \ErrorNoDeployInProgress
            console.error "no deploy in progress"
            process.exit(1)
          case \Ready
            console.error "deploy aborted"
            process.exit(0)
          default
            printDaemonMsg msg

!function displayStatus (pidfile)
  readPids pidfile, !(pids) ->
    console.log "#{pids.daemon} #{pids.master} #{pids.script}"

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Available options and their defaults:

        --worker-count 1
        --pidfile #DEFAULT_PIDFILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd #{process.cwd()}
        --tmp #{os.tmpDir()}
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'pidfile': DEFAULT_PIDFILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
        'tmp': os.tmpDir()
      [err, script] = chompArgv(options, argv)
      if not err and script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [pidfile]

        Stops the running server which created the pidfile.
        Uses `#DEFAULT_PIDFILE` by default.

        This sends SIGTERM to the process and waits for timeout, then
        sends SIGKILL if the process has not already exited.

        Available options and their defaults:

            --timeout 5
    """
    fn: (argv) ->
      options =
        timeout: '5'
      [err, pidfile or DEFAULT_PIDFILE] = chompArgv(options, argv)
      if not err and argv.length is 0
        options.timeout = parseFloat(options.timeout)
        stopScript(options, pidfile)
        true
      else
        false

  status:
    help: """
    naught status [pidfile]

        Displays whether a server is running or not.
        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      displayStatus(pidfile)
      true

  deploy:
    help: """
    naught deploy [options] [pidfile]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command.

        Naught spawns all the new workers and waits for them to all become
        online before killing a single old worker. This guarantees zero
        downtime if any of the new workers fail and provides the ability to
        cleanly abort the deployment if it hangs.

        Uses `#DEFAULT_PIDFILE` by default.

        Available options and their defaults:

            --replace-env true
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
      [err, pidfile or DEFAULT_PIDFILE] = chompArgv(options, argv)
      if not err and argv.length is 0
        options.'replace-env' = options.'replace-env' is \true
        deploy(options, pidfile)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [pidfile]

        Aborts a hanging deploy. A hanging deploy happens when a new worker
        fails to emit the 'online' message, or when an old worker fails
        to shutdown upon receiving the 'shutdown' message.

        Uses `#DEFAULT_PIDFILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      pidfile = argv.0 or DEFAULT_PIDFILE
      deployAbort(pidfile)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.error(cmd.help)
else
  printUsage()
