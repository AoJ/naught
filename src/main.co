`#!/usr/bin/env node`

const
  fs = require('fs')
  net = require('net')
  assert = require('assert')
  json_socket = require('./json_socket')
  {spawn} = require('child_process')
  path = require('path')
const DEFAULT_IPC_FILE = 'naught.ipc'

function chompArgv(obj, argv)
  while argv.length
    arg = argv.shift()
    if arg.indexOf('--') is 0
      arg_name = arg.substring(2)
      if arg_name not in obj
        return [new Error('InvalidArgument'), null]
      if argv.length is 0
        return [new Error('MissingArgument'), null]
      obj[arg_name] = argv.shift()
    else
      return [null, arg]
  return [null, null]

function connectToDaemon (socket_path, cbs)
  socket = net.connect socket_path, cbs.ready
  json_socket.listen(socket, cbs.event)
  socket

!function assertErrorIsFromInvalidSocket (error)
  throw error unless error.code is \ENOENT

function getDaemonMessages (socket_path, cbs)
  socket = connectToDaemon(socket_path, cbs)
  socket.on \error, !(error) ->
    if error.code is \ENOENT
      console.error "server not running"
      process.exit(1)
    else if error.code is \ECONNREFUSED
      console.error "unable to connect to ipc-file `#{socket_path}`"
      process.exit(1)
    else
      throw error
  socket

!function printUsage
  for name, cmd in cmds
    console.error "\n#{cmd.help}\n"

!function startScript (options, script, argv)
  socket = connectToDaemon options.'ipc-file',
    ready: !->
      json_socket.send socket, action: \NaughtStatus
    event: !(msg) ->
      if msg.event is \Status
        printStatusMsg msg
        process.exit(1)
      else
        printDaemonMsg msg
  socket.on \error, !(error) ->
    if error.code is \ECONNREFUSED
      console.error "unable to connect to ipc-file #{socket_path}"
      process.exit(1)
    else if error.code is \ENOENT
      # no server running
      child = spawn(process.execPath, [
        path.join(__dirname, "daemon.js"),
        options.'worker-count',
        options.'ipc-file',
        options.log,
        options.stderr,
        options.stdout,
        options.'max-log-size',
        script,
      ].concat(argv), {
        env: process.env
        stdio: \inherit
        detached: true
        cwd: options.cwd
      })
      child.unref()
    else
      throw error

!function stopScript (options, ipc_file)
  socket = getDaemonMessages ipc_file,
    ready: !->
      json_socket.send socket,
        action: \NaughtShutdown
        timeout: options.timeout
    event: !(msg) ->
      if msg.event is \Shutdown
        process.exit(0)
      else
        printDaemonMsg msg

!function printDaemonMsg (msg)
  console.error "event: #{msg.event}, old: #{msg.old_count}, new: #{msg.new_count}, dying: #{msg.dying_count}"

!function printStatusMsg (msg)
  if msg.waiting_for?
    console.log "deploy in progress"
    console.log "old: #{msg.old_count}, new: #{msg.new_count}, dying: #{msg.dying_count}"
  else
    console.log "server is running"
    console.log "workers online: #{msg.old_count}"

!function deploy (options, ipc_file)
  socket = getDaemonMessages ipc_file,
    ready: !->
      setAbortKeyboardHook()
      json_socket.send socket,
        action: \NaughtDeploy
        environment: if options.'replace-env' then process.env else null
        timeout: options.timeout
    event: !(msg) ->
      switch msg.event
        case \ErrorDeployInProgress
          console.error "Deploy already in progress. Press Ctrl+C to abort."
          setAbortKeyboardHook()
        case \Ready
          console.error "done"
          process.exit(0)
        default
          printDaemonMsg msg
  !function setAbortKeyboardHook
    process.once \SIGINT, !->
      console.error "aborting deploy"
      json_socket.send socket, action: \NaughtDeployAbort

!function deployAbort (ipc_file)
  socket = getDaemonMessages ipc_file,
    ready: !->
      json_socket.send socket, action: \NaughtDeployAbort
    event: !(msg) ->
      switch msg.event
        case \ErrorNoDeployInProgress
          console.error "no deploy in progress"
          process.exit(1)
        case \Ready
          console.error "deploy aborted"
          process.exit(0)
        default
          printDaemonMsg msg

!function displayStatus (ipc_file)
  socket = getDaemonMessages ipc_file,
    ready: !->
      json_socket.send socket, action: \NaughtStatus
    event: !(msg) ->
      if msg.event is \Status
        printStatusMsg msg
        process.exit(0)
      else
        printDaemonMsg msg

cmds =
  start:
    help: """
    naught start [options] server.js [script-options]

        Starts server.js as a daemon passing script-options as command
        line arguments.

        Each worker's stdout and stderr are redirected to a log files
        specified by the `stdout` and `stderr` parameters. When a log file
        becomes larger than `max-log-size`, the log file is renamed using the
        current date and time, and a new log file is opened.

        Creates an `ipc-file` which naught uses to communicate with your
        server once it has started.

        Available options and their defaults:

        --worker-count 1
        --ipc-file #DEFAULT_IPC_FILE
        --log naught.log
        --stdout stdout.log
        --stderr stderr.log
        --max-log-size 10485760
        --cwd #{process.cwd()}
      """
    fn: (argv) ->
      # parse options
      options =
        'worker-count': '1'
        'ipc-file': DEFAULT_IPC_FILE
        'log': 'naught.log'
        'stdout': 'stdout.log'
        'stderr': 'stderr.log'
        'max-log-size': '10485760'
        'cwd': process.cwd()
      [err, script] = chompArgv(options, argv)
      if not err and script?
        options.'worker-count' = parseInt(options.'worker-count')
        options.'max-log-size' = parseInt(options.'max-log-size')
        startScript(options, script, argv)
        true
      else
        false
  stop:
    help: """
    naught stop [options] [ipc-file]

        Stops the running server which created `ipc-file`.
        Uses `#DEFAULT_IPC_FILE` by default.

        This sends the 'shutdown' message to all the workers and waits for
        them to exit gracefully.

        If you specify a timeout, naught will forcefully kill your workers
        if they do not shut down gracefully within the timeout.

        Available options and their defaults:

            --timeout none
    """
    fn: (argv) ->
      options =
        timeout: 'none'
      [err, ipc_file or DEFAULT_IPC_FILE] = chompArgv(options, argv)
      if not err and argv.length is 0
        options.timeout = parseFloat(options.timeout)
        options.timeout = null if isNaN(options.timeout)
        stopScript(options, ipc_file)
        true
      else
        false

  status:
    help: """
    naught status [ipc-file]

        Displays whether a server is running or not.
        Uses `#DEFAULT_IPC_FILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      ipc_file = argv.0 or DEFAULT_IPC_FILE
      displayStatus(ipc_file)
      true

  deploy:
    help: """
    naught deploy [options] [ipc-file]

        Replaces workers with new workers using new code and optionally
        the environment variables from this command.

        Naught spawns all the new workers and waits for them to all become
        online before killing a single old worker. This guarantees zero
        downtime if any of the new workers fail and provides the ability to
        cleanly abort the deployment if it hangs.

        A hanging deploy happens when a new worker fails to emit the 'online'
        message, or when an old worker fails to shutdown upon receiving the
        'shutdown' message. A keyboard interrupt will cause a deploy-abort,
        cleanly and with zero downtime.

        If `timeout` is specified, naught will automatically abort the deploy
        if it does not finish within those seconds.

        Uses `#DEFAULT_IPC_FILE` by default.

        Available options and their defaults:

            --replace-env true
            --timeout none
    """
    fn: (argv) ->
      options =
        'replace-env': 'true'
        'timeout': 'none'
      [err, ipc_file or DEFAULT_IPC_FILE] = chompArgv(options, argv)
      if not err and argv.length is 0
        options.'replace-env' = options.'replace-env' is \true
        options.timeout = parseFloat(options.timeout)
        options.timeout = null if isNaN(options.timeout)
        deploy(options, ipc_file)
        true
      else
        false
  'deploy-abort':
    help: """
    naught deploy-abort [icp-file]

        Aborts a hanging deploy. A hanging deploy happens when a new worker
        fails to emit the 'online' message, or when an old worker fails
        to shutdown upon receiving the 'shutdown' message.

        When deploying, a keyboard interrupt will cause a deploy-abort,
        so the times you actually have to run this command will be few and
        far between.

        Uses `#DEFAULT_IPC_FILE` by default.
    """
    fn: (argv) ->
      return false if argv.length > 1
      ipc_file = argv.0 or DEFAULT_IPC_FILE
      deployAbort(ipc_file)
      true

  help:
    help: """
    naught help [cmd]

        Displays help for cmd.
    """
    fn: (argv) ->
      if argv.length is 1 and (cmd = cmds[argv[0]])?
        console.log(cmd.help)
      else
        printUsage()
      true

if (cmd = cmds[process.argv[2]])?
  if not cmd.fn(process.argv.slice(3))
    console.error(cmd.help)
else
  printUsage()
