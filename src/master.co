const
  cluster = require('cluster')
  assert = require('assert')
  async = require('async')

argv = process.argv.slice(2)
worker_count = parseInt(argv.shift())
script = argv.shift()

cluster.setupMaster do
  exec: script
  args: argv

# workers move from here to dying_workers when we ask them to 'shutdown'
workers = newWorkerCollection()
# workers go here until they all have emitted 'online'
new_workers = newWorkerCollection()
# workers in here have been asked to 'shutdown'
dying_workers = newWorkerCollection()
waiting_for = null

abort_timeout = null
process.on \message, !(message) ->
  switch message.action
    case \NaughtDeploy
      process.env <<< message.environment
      deployStart()
      if (timeout = message.timeout)?
        abort_timeout := setTimeout(deployAbort, timeout * 1000)
    case \NaughtDeployAbort then deployAbort()
    case \NaughtShutdown
      shutdownAll()
      if (timeout = message.timeout)?
        setTimeout(destroyAll, timeout * 1000)
    case \NaughtStatus
      event \Status
    default then event \UnrecognizedMessage

event \Bootup
addWorker(workers, makeWorker()) for i from 0 til worker_count

function newWorkerCollection then do
  hash: {}
  count: 0

!function addWorker (collection, worker)
  pid = worker.process.pid
  {hash} = collection
  if pid not in hash
    collection.count += 1
  hash[pid] = worker

function removeWorker (collection, pid)
  {hash} = collection
  assert pid in hash
  collection.count -= 1
  delete hash[pid]

function shiftWorker (collection)
  for pid in collection.hash
    return removeWorker(collection, pid)
  assert false

!function forEachWorker (collection, cb)
  cb(pid, worker) for pid, worker in collection.hash

!function onceOnline (worker, cb)
  worker.on(\message, onMessage)
  !function onMessage(message)
    if message is \online
      worker.removeListener(\message, onMessage)
      cb()

function makeWorker
  worker = cluster.fork()
  worker.once \exit, !->
    # ignore if this happened due to a deployment
    return if waiting_for?

    event \WorkerDeath
    removeWorker(workers, worker.process.pid)
    addWorker(workers, makeWorker())
  if waiting_for!?
    onceOnline worker, !->
      event \WorkerOnline
  worker

!function event (name)
  process.send do
    new_count: new_workers.count
    old_count: workers.count
    dying_count: dying_workers.count
    waiting_for: waiting_for
    event: name

!function spawnNew (cb)
  assert new_workers.count < worker_count
  event \SpawnNew
  addWorker new_workers, new_worker = makeWorker()
  onceOnline new_worker, !->
    event \NewOnline
    cb()

!function shutdownOneWorker (collection, cb)
  assert collection.count > 0
  event \ShutdownOld
  addWorker dying_workers, dying_worker = shiftWorker(collection)
  dying_worker.disconnect()
  dying_worker.send \shutdown
  dying_worker.once \exit, !->
    event \OldExit
    removeWorker dying_workers, dying_worker.process.pid
    cb()

!function shutdownOld (cb)
  shutdownOneWorker(workers, cb)

!function shutdownNew (cb)
  shutdownOneWorker(new_workers, cb)

!function deployStart
  if waiting_for?
    event \ErrorDeployInProgress
    return

  waiting_for := \new
  async.parallel (spawnNew for i from 0 til worker_count), !->
    assert new_workers.count is worker_count
    waiting_for := \old
    async.parallel (shutdownOld for i from 0 til worker_count), !->
      assert workers.count is 0
      assert dying_workers.count is 0
      event \Ready
      waiting_for := null
      if abort_timeout?
        clearTimeout(abort_timeout)
        abort_timeout := null
      [workers, new_workers] := [new_workers, workers]

!function destroyNew (cb)
  event \DestroyNew
  new_worker = shiftWorker(new_workers)
  new_worker.once \exit, cb
  new_worker.destroy()

!function deployAbort
  switch waiting_for
    case \new
      async.parallel (destroyNew for i from 0 til new_workers.count), !->
        event \Ready
        waiting_for := null
    case \old
      destroyDying()
    default
      event \ErrorNoDeployInProgress

!function shutdownAll
  waiting_for := \shutdown
  funcs_old = (shutdownOld for i from 0 til workers.count)
  funcs_new = (shutdownNew for i from 0 til new_workers.count)
  async.parallel funcs_old.concat(funcs_new), !-> process.exit(0)

!function destroyDying
  forEachWorker dying_workers, !(pid, dying_worker) ->
    event \DestroyOld
    dying_worker.destroy()

!function destroyAll
  assert workers.count is 0
  assert new_workers.count is 0
  destroyDying()
