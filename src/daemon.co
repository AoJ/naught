const
  fs = require('fs')
  mkdirp = require('mkdirp')
  path = require('path')
  {spawn} = require('child_process')
  net = require('net')
  assert = require('assert')
  async = require('async')
  json_socket = require('./json_socket')
  createLog = require('./log').create

  argv = process.argv.slice(2)
  worker_count = parseInt(argv.shift())
  socket_path = argv.shift()
  log_naught_path = argv.shift()
  log_stderr_path = argv.shift()
  log_stdout_path = argv.shift()
  max_log_size = parseInt(argv.shift())
  script = argv.shift()
  node_args_str = argv.shift()

logs = null
socket = null
master = null
server = null

!function maybeCreateLog(log_path, cb)
  # special case /dev/null - disable logging altogether
  if log_path is '/dev/null'
    cb(null, null)
  else
    createLog(log_path, max_log_size, cb)

!function createLogs(cb)
  async.parallel {
    naught: !(cb) -> maybeCreateLog(log_naught_path, cb)
    stderr: !(cb) -> maybeCreateLog(log_stderr_path, cb)
    stdout: !(cb) -> maybeCreateLog(log_stdout_path, cb)
  }, !(err, results) ->
    return cb(err) if err
    logs := results
    logs.stderr?on \error, !(err) ->
      log "Error writing to #{log_stderr_path}: #{err.stack}\n"
    logs.stdout?on \error, !(err) ->
      log "Error writing to #{log_stdout_path}: #{err.stack}\n"
    logs.naught?on \error, !(err) ->
      process.stderr.write("Error writing to #{log_naught_path}: #{err.stack}\n")
    cb()

!function log (str)
  logs.naught?write(str)
  process.stderr.write(str)

function workerCountsFromMsg (msg)
  "booting: #{msg.count?booting}, \
  online: #{msg.count?online}, \
  dying: #{msg.count?dying}, \
  new_booting: #{msg.count?new_booting}, \
  new_online: #{msg.count?new_online}"

!function onMessage (message)
  logs.naught?write("#{message.event}. #{workerCountsFromMsg(message)}\n")
  if socket? then json_socket.send(socket, message)

!function createLogsAndIpcServer(cb)
  async.parallel [
    createLogs,
    !(cb) -> mkdirp(path.dirname(socket_path), cb)
  ], !(err) ->
    return cb(err) if err
    server := net.createServer !(new_socket) ->
      if socket?
        log "Warning: Only one connection to daemon allowed. Terminating old connection.\n"
        socket.destroy()
      socket := new_socket
      socket.on \error, !(err) ->
        log "Error: ipc channel socket: #{err.stack}\n"
      socket.once \end, !->
        socket := null
      json_socket.listen socket, !(msg) ->
        if master?
          if msg.action is \NaughtDeploy
            process.env <<< msg.environment
          master.send msg
        else
          json_socket.send socket, event: \ErrorStillBooting
    server.listen socket_path, !->
      process.send(\IpcListening)
      cb()

!function spawnMaster
  node_args = splitCmdLine(node_args_str)
  console.error "node_args", node_args
  stdout_behavior = if logs.stdout? then 'pipe' else 'ignore'
  stderr_behavior = if logs.stderr? then 'pipe' else 'ignore'
  console.log "stdout beh", stdout_behavior
  master := spawn(process.execPath, node_args.concat([
    path.join(__dirname, "master.js"),
    worker_count,
    script,
  ]).concat(argv), {
    env: process.env
    stdio: [process.stdin, stdout_behavior, stderr_behavior, 'ipc']
    cwd: process.cwd()
  })
  master.on \message, onMessage
  if logs.stdout?
    master.stdout.on \data, logs.stdout.write
  if logs.stderr?
    master.stderr.on \data, logs.stderr.write
  master.on \close, !->
    onMessage do
      event: \Shutdown
      count:
        booting: 0
        online: 0
        dying: 0
        new_booting: 0
        new_online: 0
    server.close()

function splitCmdLine (str)
  if str.length is 0
    []
  else
    str.split(/\s+/)

createLogsAndIpcServer !(err) ->
  assert.ifError(err)
  spawnMaster()
